# [FR-009] Persistent History with PostgreSQL

## Labels
`MUS`, `feature`, `database`, `history`

## User Story
As a user, I want all my transcriptions to be saved to a local database, so that I can access my history forever and copy from previous recordings.

## Proposed Solution

### Overview
Store all recordings and transcriptions in a local PostgreSQL database. Provide a history view that shows recent transcriptions with search and copy functionality.

### Implementation Flow
1. Recording starts → Create database entry
2. Recording completes → Update with audio path
3. Transcription completes → Update with transcript
4. User opens history view → Query last 50 recordings
5. User clicks copy → Copy transcript to clipboard

### Technical Approach

**Database Schema:**
```sql
-- Recordings table
CREATE TABLE recordings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    audio_path TEXT,
    raw_text TEXT,
    refined_text TEXT,
    mode VARCHAR(20) DEFAULT 'raw',
    status VARCHAR(20) DEFAULT 'recording',
    retry_count INTEGER DEFAULT 0,
    duration_seconds INTEGER,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_recordings_created_at ON recordings(created_at DESC);
CREATE INDEX idx_recordings_status ON recordings(status);
```

**Rust Database Layer:**
```rust
// src-tauri/src/db/mod.rs
use sqlx::PgPool;
use uuid::Uuid;

pub struct Database {
    pool: PgPool,
}

impl Database {
    pub async fn new(connection_string: &str) -> Result<Self, sqlx::Error> {
        let pool = PgPool::connect(connection_string).await?;
        Ok(Self { pool })
    }
    
    pub async fn create_recording(&self) -> Result<Uuid, sqlx::Error> {
        let id = Uuid::new_v4();
        sqlx::query(
            "INSERT INTO recordings (id) VALUES ($1)"
        )
        .bind(id)
        .execute(&self.pool)
        .await?;
        
        Ok(id)
    }
    
    pub async fn update_audio_path(
        &self,
        id: Uuid,
        path: &str,
        duration: i32
    ) -> Result<(), sqlx::Error> {
        sqlx::query(
            "UPDATE recordings SET audio_path = $1, duration_seconds = $2, status = 'completed' WHERE id = $3"
        )
        .bind(path)
        .bind(duration)
        .bind(id)
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }
    
    pub async fn get_recent_recordings(
        &self,
        limit: i64
    ) -> Result<Vec<Recording>, sqlx::Error> {
        sqlx::query_as::<_, Recording>(
            r#"
            SELECT * FROM recordings
            WHERE status = 'completed'
            ORDER BY created_at DESC
            LIMIT $1
            "#
        )
        .bind(limit)
        .fetch_all(&self.pool)
        .await
    }
}
```

**History Component:**
```tsx
// src/components/HistoryPanel.tsx
export function HistoryPanel() {
  const [recordings, setRecordings] = useState<Recording[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  
  useEffect(() => {
    loadHistory();
  }, []);
  
  const loadHistory = async () => {
    const data = await invoke<Recording[]>('get_recent_recordings', { limit: 50 });
    setRecordings(data);
  };
  
  const filtered = recordings.filter(r => 
    r.raw_text?.toLowerCase().includes(searchQuery.toLowerCase())
  );
  
  return (
    <div className="p-4">
      <input
        type="text"
        placeholder="Search history..."
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value)}
        className="w-full bg-surface rounded-lg px-4 py-2 mb-4"
      />
      
      <div className="space-y-2">
        {filtered.map((recording) => (
          <HistoryItem 
            key={recording.id} 
            recording={recording}
            onCopy={() => copyToClipboard(recording.raw_text)}
          />
        ))}
      </div>
    </div>
  );
}
```

### Key Considerations
- Database connection string from environment variable
- Handle connection failures gracefully
- Implement pagination for large history
- Search functionality across transcripts

## Acceptance Criteria

- [ ] All recordings saved to PostgreSQL database
- [ ] History view shows last 50 transcriptions
- [ ] Search functionality works across transcripts
- [ ] Copy button copies transcript to clipboard
- [ ] Database schema includes all required fields
- [ ] Connection to local PostgreSQL works
- [ ] Graceful error handling for DB connection issues
- [ ] History persists across app restarts
