# [FR-006] Retry Mode for Failed Transcriptions

## Labels
`MUS`, `core`, `reliability`, `offline`

## User Story
As a user with intermittent internet, I want to retry transcription if it fails due to network issues, so that I don't lose my recording when my connection is bad.

## Proposed Solution

### Overview
Store audio files locally during transcription attempts. If the transcription fails (network error, timeout, API error), keep the audio file and allow the user to retry. Show clear status indicators for retry availability.

### Implementation Flow
1. Recording completes, audio saved to temp directory
2. Transcription attempt begins
3. If network/API error occurs:
   - Mark recording status as 'failed'
   - Keep audio file in temp storage
   - Show retry button in UI
4. User clicks retry, transcription re-attempted
5. On success, move audio to permanent storage or delete
6. After 24 hours (configurable), clean up temp files

### Technical Approach

**Database Schema:**
```sql
ALTER TABLE recordings ADD COLUMN retry_count INTEGER DEFAULT 0;
ALTER TABLE recordings ADD COLUMN error_message TEXT;
ALTER TABLE recordings ADD COLUMN audio_retained_until TIMESTAMP;
```

**Rust Backend:**
```rust
// src-tauri/src/commands/retry.rs
use crate::db::Database;
use crate::services::groq::transcribe_audio;

#[tauri::command]
pub async fn retry_transcription(
    recording_id: String,
    state: State<'_, AppState>,
) -> Result<String, String> {
    let db = &state.db;
    
    // Get recording details
    let recording = db.get_recording(&recording_id).await
        .map_err(|e| e.to_string())?;
    
    // Check if audio file still exists
    if !std::path::Path::new(&recording.audio_path).exists() {
        return Err("Audio file no longer available".to_string());
    }
    
    // Increment retry count
    db.increment_retry_count(&recording_id).await
        .map_err(|e| e.to_string())?;
    
    // Attempt transcription again
    let api_key = std::env::var("GROQ_API_KEY")
        .map_err(|_| "API key not configured".to_string())?;
    
    match transcribe_audio(&api_key, &recording.audio_path).await {
        Ok(transcript) => {
            // Update recording with transcript
            db.update_transcript(&recording_id, &transcript).await
                .map_err(|e| e.to_string())?;
            
            // Update status to completed
            db.update_status(&recording_id, "completed").await
                .map_err(|e| e.to_string())?;
            
            Ok(transcript)
        }
        Err(e) => {
            // Update error message
            db.update_error(&recording_id, &e).await
                .map_err(|e| e.to_string())?;
            
            Err(format!("Transcription failed: {}", e))
        }
    }
}
```

**Frontend:**
```tsx
// src/components/RetryButton.tsx
export function RetryButton({ recordingId, onRetry }: RetryButtonProps) {
  const [isRetrying, setIsRetrying] = useState(false);
  
  const handleRetry = async () => {
    setIsRetrying(true);
    try {
      const transcript = await invoke('retry_transcription', { recordingId });
      onRetry(transcript);
    } catch (error) {
      toast.error(`Retry failed: ${error}`);
    } finally {
      setIsRetrying(false);
    }
  };
  
  return (
    <Button onClick={handleRetry} disabled={isRetrying}>
      {isRetrying ? <Spinner /> : <RefreshCw />}
      Retry Transcription
    </Button>
  );
}
```

### Key Considerations
- Audio files kept for 24 hours (configurable) before cleanup
- Maximum retry attempts: 5 (configurable)
- Clear error messages for different failure types
- Background cleanup job for expired temp files

## Acceptance Criteria

- [ ] Audio file retained locally on transcription failure
- [ ] Retry button appears for failed transcriptions
- [ ] Retry attempts are tracked (retry count)
- [ ] Successful retry updates recording status to 'completed'
- [ ] Error messages clearly indicate why transcription failed
- [ ] Audio files auto-deleted after 24 hours
- [ ] Maximum 5 retry attempts per recording
- [ ] Works offline (shows appropriate message)
